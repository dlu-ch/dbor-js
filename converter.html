 <!--
SPDX-License-Identifier: LGPL-3.0-or-later
dbor-js - ECMAScript 2020 implementation of DBOR encoder
Copyright (C) 2020 Daniel Lutz <dlu-ch@users.noreply.github.com>

Requires browser supports of:
- HTML compliant with https://www.w3.org/TR/html401/
- CSS compliant with https://www.w3.org/TR/css-values-3/
- W3C DOM compliant with https://www.w3.org/TR/dom41/
- ECMAScript 2020 compliant with https://www.ecma-international.org/ecma-262/11.0/
-->

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html lang="en">
  <head>
    <title>Encode to DBOR</title>

    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">

    <!-- avoid import (not usable with local files due to CORS restrictions e.g. in Firefox 68) -->
    <script type="text/javascript" src="./src/dbor-encode.js"></script>
    <script type="text/javascript" src="./src/textobj-parse.js"></script>

    <style type="text/css">
      body {
        font-family: Helvetica, Arial, sans-serif;
      }

      table.alignonly {
        border: none;
        border-spacing: 0px;
      }
      table.alignonly tr td.firstcol {
        padding-right: 1em;
      }
      table.alignonly tr td.firstcol {
        padding-left: 0px;
      }

      div#div-representation textarea {
        padding: 0.5ex;
        border-left: 3px solid;
        border-right: 1px;
        border-left-color: gray;
      }
      div#div-representation.invalid textarea#textarea-input {
        border-left-color: red;
      }
      div#div-representation.valid textarea#textarea-input {
        border-left-color: RoyalBlue;
      }
      div#div-representation #span-encoding-error {
        color: red;
      }
    </style>
  </head>

  <body>
    <div id="div-representation">
      <div class="textareacontainer">
        Objects to encode:
        <!-- note: placeholder is not supported by HTML 4.01 -->
        <textarea id="textarea-input" rows="1" cols="1" placeholder="e.g '12.5*2^-6, 16#FFFF_BEAF'"
                  style="width: calc(100% - 10px); resize: none; height: 10ex; max-height: 10ex; white-space: pre">
        </textarea>
      </div>

      <p></p>
      <table class="alignonly">
        <tr>
          <td class="firstcol"><button id="button-encode" title="Ctrl+Enter">Encode</button></td>
          <td><span id="span-encoding-error">&#x26A0; Browser does not comply with ECMAScript 2020 or scripts are (partially) disabled.</span></td>
        </tr>
      </table>
      <p></p>

      <div class="textareacontainer">
        Corresponding DBOR encoded byte sequence:
        <textarea id="textarea-dborbytes" readonly rows="1" cols="1"
                  style="width: calc(100% - 10px); resize: none; height: 10ex; max-height: 10ex"></textarea>
      </div>
    </div>

    <script type="text/javascript">
      "use strict";

      // TODO jump to input on click on line:column of error
      // TODO group bytes by encoded object and link objects with corresponding bytes
      // TODO improve error encoder messages

      function setEncodingState (isComplete = false, outputBytes = null, errorMessage = null) {
        const representationElement = document.getElementById('div-representation');
        const outputElement = document.getElementById('textarea-dborbytes');
        const stateElement = document.getElementById('span-encoding-error');
        const encodeButtonElement = document.getElementById('button-encode');

        const stringifiedBytes = outputBytes ? outputBytes.map(b => '0x' + b.toString(16).padStart(2, '0').toUpperCase()).join(', ') : [];
        outputElement.value = stringifiedBytes;

        representationElement.classList.toggle('invalid', errorMessage);
        representationElement.classList.toggle('valid', !errorMessage && outputBytes);

        stateElement.textContent = errorMessage || '';
        encodeButtonElement.disabled = isComplete;
      }


      function markInputAsChanged () {
        setEncodingState();
      }


      function encodeInput () {
        const inputElement = document.getElementById('textarea-input');

        const input = inputElement.value || '';
        let encoder = new dbor.Encoder();

        try {
          let inputRangesWithObjects = new textobj.Parser(input).parse();

          for (let inputRangeWithObject of inputRangesWithObjects) {
            const object = inputRangeWithObject.object;
            try {
              if (!(object instanceof textobj.IntegerWithExpFactor))
                throw new TypeError('unsupported type');
              const number = object;
              if (number.mant === 0n && number.isNeg)
                encoder.appendMinusZero()
              else if (!number.base)
                encoder.appendInteger(number.mant)
              else if (number.base === 10n)
                encoder.appendDecimalRational(number.mant, number.exp)
              else
                encoder.appendBinaryRational(number.mant, number.exp);
            } catch (error) {
              throw new textobj.InputError(error.message, inputRangeWithObject.index);
            }
          }

          setEncodingState(true, encoder.bytes);

        } catch (error) {
          let errorMsg = error.message;

          if (error instanceof textobj.InputError) {
            let [lineIndex, columnIndex] = textobj.makeIndexRelativeToLine(error.index, input);
            errorMsg = `\u{26A0} line ${lineIndex + 1}:${columnIndex + 1}: ${errorMsg}`;
            // set cursor immediately before first invalid character
            inputElement.focus();
            inputElement.setSelectionRange(error.index, error.index);  // index: UTF-16 code units (not codepoints)
          }

          setEncodingState(true, [], errorMsg);
        }

      }

      BigInt(0);  // introduced with ECMAScript 2020

      const inputElement = document.getElementById('textarea-input');
      inputElement.oninput = markInputAsChanged;
      inputElement.onkeypress = function (event) {
        let ctrlPlusEnterPressed = false;
        try{ ctrlPlusEnterPressed = event.ctrlKey && event.code == 'Enter' } catch (e) {};
        if (ctrlPlusEnterPressed)
          encodeInput();
      };
      document.getElementById('button-encode').onclick = encodeInput;

      const initialInput = new URL(window.location).searchParams.get('q');
      if (initialInput !== null) {
        inputElement.value = initialInput;
        encodeInput();
      } else
        markInputAsChanged();  // replace static content that basically says: "not working"
    </script>
  </body>

</html>