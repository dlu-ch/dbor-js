 <!--
SPDX-License-Identifier: LGPL-3.0-or-later
dbor-js - ECMAScript 2020 implementation of DBOR encoder
Copyright (C) 2020 Daniel Lutz <dlu-ch@users.noreply.github.com>

Requires browser supports of:
- HTML compliant with https://www.w3.org/TR/html401/
- CSS compliant with https://www.w3.org/TR/css-values-3/
- W3C DOM compliant with https://www.w3.org/TR/dom41/
- ECMAScript 2020 compliant with https://www.ecma-international.org/ecma-262/11.0/
-->

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html lang="en">
  <head>
    <title>Encode to DBOR</title>

    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">

    <!-- avoid import (not usable with local files due to CORS restrictions e.g. in Firefox 68) -->
    <script type="text/javascript" src="./src/dbor-encode.js"></script>
    <script type="text/javascript" src="./src/textobj-parse.js"></script>

    <style type="text/css">
      body {
        font-family: Helvetica, Arial, sans-serif;
      }

      table.alignonly {
        border: none;
        border-spacing: 0px;
      }
      table.alignonly tr td.firstcol {
        padding-right: 1em;
      }
      table.alignonly tr td.firstcol {
        padding-left: 0px;
      }

      div#div-representation textarea.input,
      div#div-representation div.noninput {
        font-size: smaller;
        font-family: 'Courier New', Courier, monospace;
        padding: 0.5ex;
        border: 1px inset #ccc;
        border-left: 3px solid;
        border-left-color: gray;
        overflow: auto;  /* scrollbar if content too large */
      }
      div#div-representation.invalid textarea.input {
        border-left-color: red;
      }
      div#div-representation.valid textarea.input {
        border-left-color: RoyalBlue;
      }
      div#div-representation #span-encoding-error {
        color: red;
      }

      span.sequence span.firstinsequence {
        font-weight: bold;
      }
      span.sequence.dbor-number span.firstinsequence,
      span.sequence.dbor-numberlike span.firstinsequence {
        color: black;
      }

      a.underlinedonhover {
        border-bottom: none;
        text-decoration: none;
      }
      a.underlinedonhover:hover {
        border-bottom: 1px dotted;
      }

      a.underlined {
        border-bottom: 1px dotted;
        text-decoration: none;
      }

      a.withinheritedcolor,
      a.withinheritedcolor:hover {
        color: inherit;
      }

    </style>
  </head>

  <body>
    <div id="div-representation">
      <div class="textareacontainer">
        Objects to encode:
        <!-- note: placeholder is not supported by HTML 4.01 -->
        <textarea id="textarea-input" rows="1" cols="1" placeholder="e.g '12.5*2^-6, 16#FFFF_BEAF'"
                  class="input"
                  style="width: calc(100% - 10px); resize: none; height: 10ex; max-height: 10ex; white-space: pre">
        </textarea>
      </div>

      <p></p>
      <table class="alignonly">
        <tr>
          <td class="firstcol"><button id="button-encode" title="Ctrl+Enter">Encode</button></td>
          <td><span id="span-encoding-error">&#x26A0; Browser does not comply with ECMAScript 2020 or scripts are (partially) disabled.</span></td>
        </tr>
      </table>
      <p></p>

      <div class="textareacontainer">
        Corresponding DBOR encoded byte sequence:
        <div id="div-dborbytes" class="noninput"
             style="width: calc(100% - 10px); resize: none; height: 10ex; max-height: 10ex">
        </div>
      </div>
    </div>

    <script type="text/javascript">
      "use strict";

      function setEncodingState (isComplete = false, inputRangesWithEncodedObjects = null, errorMarkup = null) {
        const representationElement = document.getElementById('div-representation');
        const outputElement = document.getElementById('div-dborbytes');
        const stateElement = document.getElementById('span-encoding-error');
        const encodeButtonElement = document.getElementById('button-encode');

        if (inputRangesWithEncodedObjects) {
          let outputMarkups = [];
          const byteSeparator = ' ';
          for (let r of inputRangesWithEncodedObjects) {
            const [dborClass, bytes] = r.object;
            let cssClass = dborClass.toLowerCase();
            cssClass = cssClass.match(/^[a-z]+$/) ? `dbor-${cssClass}` : '';
            const hexBytes = bytes.map(b => b.toString(16).padStart(2, '0').toUpperCase());
            if (hexBytes.length > 0) {
              let s = `<span class="firstinsequence">${hexBytes[0]}</span>`;
              if (hexBytes.length > 1)
                s += byteSeparator + hexBytes.slice(1).join(byteSeparator);
              const outputMarkup =
                `<span class="sequence ${cssClass}">` +
                  `<a class="withinheritedcolor underlinedonhover" href="javascript:selectInInput(${r.index}, ${r.length})">` +
                    `${s}` +
                  `</a>` +
                `</span>`;
              outputMarkups.push(outputMarkup);
            }
          }
          outputElement.innerHTML = outputMarkups.join(byteSeparator);
        } else {
          outputElement.innerText = '';
        }

        representationElement.classList.toggle('invalid', errorMarkup);
        representationElement.classList.toggle('valid', !errorMarkup && inputRangesWithEncodedObjects);

        stateElement.innerHTML = errorMarkup ? `\u{26A0} ${errorMarkup}` : '';
        encodeButtonElement.disabled = isComplete;
      }


      function selectInInput (index, length = 0) {
        index = Number(index);
        length = Number(length);
        if (index >= 0 && length >= 0) {
          const inputElement = document.getElementById('textarea-input');
          inputElement.focus();
          inputElement.setSelectionRange(index, index + length);  // index: UTF-16 code units (not codepoints)
        }
      }


      function markInputAsChanged () {
        setEncodingState();
      }


      function encodeInput () {
        const inputElement = document.getElementById('textarea-input');

        const input = inputElement.value || '';

        try {
          let inputRangesWithObjects = new textobj.Parser(input).parse();
          let inputRangesWithEncodedObjects = [];

          for (let inputRangeWithObject of inputRangesWithObjects) {
            const object = inputRangeWithObject.object;
            try {
              let encoder = new dbor.Encoder();

              if (!(object instanceof textobj.IntegerWithExpFactor))
                throw new TypeError('unsupported type');

              // TODO improve error encoder messages

              const number = object;
              let dborClass = 'Number';
              if (number.mant === 0n && number.isNeg) {
                encoder.appendMinusZero();
                dborClass = 'Numberlike';
              } else if (!number.base) {
                encoder.appendInteger(number.mant);
              } else if (number.base === 10n) {
                if (number.exp != 0n)
                  encoder.appendDecimalRational(number.mant, number.exp)
                else
                  encoder.appendInteger(number.mant)
              } else {
                encoder.appendBinaryRational(number.mant, number.exp);
              }

              inputRangesWithEncodedObjects.push(
                new textobj.InputRange(
                  inputRangeWithObject.index, inputRangeWithObject.length,
                  [dborClass, encoder.bytes]));
            } catch (error) {
              throw new textobj.InputError(error.message, inputRangeWithObject.index);
            }
          }

          setEncodingState(true, inputRangesWithEncodedObjects);

        } catch (error) {
          const node = document.createElement('span');
          node.textContent = error.message;
          let errorMarkup = node.innerHTML;

          if (error instanceof textobj.InputError) {
            let [lineIndex, columnIndex] = textobj.makeIndexRelativeToLine(error.index, input);
            const linenoMarkup =
              `<span class="lineno"><a class="withinheritedcolor underlined" href="javascript:selectInInput(${error.index})">` +
                `line ${lineIndex + 1}:${columnIndex + 1}` +
              `</a></span>`;
            errorMarkup = `${linenoMarkup}: ${errorMarkup}`;
            selectInInput(error.index);  // set cursor immediately before first invalid character
          }

          setEncodingState(true, [], errorMarkup);
        }

      }

      BigInt(0);  // introduced with ECMAScript 2020

      const inputElement = document.getElementById('textarea-input');
      inputElement.oninput = markInputAsChanged;
      inputElement.onkeypress = function (event) {
        let ctrlPlusEnterPressed = false;
        try {
          ctrlPlusEnterPressed = event.ctrlKey &&
            (event.code == 'Enter' || event.code == 'NumpadEnter')
        } catch (e) {};
        if (ctrlPlusEnterPressed)
          encodeInput();
      };
      document.getElementById('button-encode').onclick = encodeInput;

      const initialInput = new URL(window.location).searchParams.get('q');
      if (initialInput !== null) {
        inputElement.value = initialInput;
        encodeInput();
      } else
        markInputAsChanged();  // replace static content that basically says: "not working"
    </script>
  </body>

</html>